// Package main provides a simple illustration of setting up a web server
// with data processing capabilities using Kafka for simulating data streams.
// The application also demonstrates a basic pattern for concurrent data production
// and consumption in Go using the Kafka library.
package main

import (
	"context"
	"github.com/gin-gonic/gin"
	"github.com/segmentio/kafka-go"
	"log"
	"time"
)

// main initializes a Gin HTTP server and sets up routing.
func main() {
	r := gin.Default()

	r.GET("/process-data", func(c *gin.Context) {
		go produceKafkaMessages() // Asynchronously produce Kafka messages
		consumeKafkaMessages()    // Synchronously consume Kafka messages
		c.JSON(200, gin.H{
			"message": "Data processing initiated. Check logs for details.",
		})
	})

	r.Run() // Starts the HTTP server on default port 8080.
}

// produceKafkaMessages sends a series of messages to a Kafka topic asynchronously.
// This function simulates the production of data which could be generated by various
// sources in a real-world application.
func produceKafkaMessages() {
	w := kafka.NewWriter(kafka.WriterConfig{
		Brokers:  []string{"localhost:9092"},
		Topic:    "tickets",
		Balancer: &kafka.LeastBytes{},
	})

	defer w.Close()

	for i := 0; i < 10; i++ {
		err := w.WriteMessages(context.Background(),
			kafka.Message{
				Key:   []byte{byte(i)},
				Value: []byte("valid ticket information"),
			},
		)

		if err != nil {
			log.Printf("failed to write messages: %s", err)
			return
		}
	}
	log.Println("Produced 10 messages.")
}

// consumeKafkaMessages receives messages from a Kafka topic and processes them.
// This function illustrates the consumer part of the Kafka messaging system.
// In a full-fledged application, this method could involve complex data processing logic.
func consumeKafkaMessages() {
	r := kafka.NewReader(kafka.ReaderConfig{
		Brokers:   []string{"localhost:9092"},
		Topic:     "tickets",
		Partition: 0,
		MinBytes:  10e3, // 10KB
		MaxBytes:  10e6, // 10MB
	})

	defer r.Close()
	for {
		m, err := r.ReadMessage(context.Background())
		if err != nil {
			log.Printf("error while receiving message: %s", err)
			continue
		}
		log.Printf("message at offset %d: %s = %s", m.Offset, string(m.Key), string(m.Value))
		processData(string(m.Value)) // Simulate processing of received data
	}
}

// processData simulates a data processing operation.
// Here, data is logged and a time delay is introduced to simulate processing time.
func processData(data string) {
	log.Printf("Processing data: %s", data)
	time.Sleep(1 * time.Second) // Simulate time-consuming processing
}
